import 'dart:io';

import 'package:flutter_test/flutter_test.dart';
import 'package:hive/hive.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:path_provider_platform_interface/path_provider_platform_interface.dart';
import 'package:tasker/src/data/models/priority_level.dart';
import 'package:tasker/src/data/models/task.dart';
import 'package:tasker/src/data/providers/task_provider.dart';

import 'task_provider_test.mocks.dart'; // Generated by mockito

class MockPathProviderPlatform extends Fake implements PathProviderPlatform {
  @override
  Future<String?> getApplicationDocumentsPath() async {
    return 'your path';
  }

  @override
  Future<String?> getApplicationSupportPath() async {
    return 'your path';
  }
}

@GenerateMocks([Box, Task])
void main() {
  TestWidgetsFlutterBinding.ensureInitialized();
  late MockBox<Task> mockTaskBox;
  late TaskProvider taskProvider;
  late MockTask mockTask;
  late Directory tempDir;
  late MockPathProviderPlatform mockPathProviderPlatform;

  setUpAll(() async {
    // Create a mock instance of PathProviderPlatform
    mockPathProviderPlatform = MockPathProviderPlatform();
    // Register the mock instance
    PathProviderPlatform.instance = mockPathProviderPlatform;

    // Get a temporary directory for testing
    tempDir = await Directory.systemTemp.createTemp();
    // Initialize Hive with the temporary directory
    Hive.init(tempDir.path);
    // Register the adapter for Task
    Hive.registerAdapter(TaskAdapter());
    Hive.registerAdapter(PriorityLevelAdapter());
  });

  setUp(() async {
    mockTaskBox = MockBox<Task>();
    mockTask = MockTask();
    taskProvider = TaskProvider();
    taskProvider.taskBox = mockTaskBox;
  });

  tearDown(() async {
    taskProvider.dispose();
    // Clean up the box after each test
    await Hive.deleteFromDisk();
  });

  tearDownAll(() async {
    // Clean up the temporary directory after all tests
    await tempDir.delete(recursive: true);
  });

  group('TaskProvider', () {
    test(
      'addTask() should add a task to the box and notify listeners',
      () async {
        // Arrange
        when(mockTaskBox.add(any)).thenAnswer((_) async => 0);
        when(mockTaskBox.values).thenReturn([]);

        // Act
        await taskProvider.addTask(mockTask);

        // Assert
        verify(mockTaskBox.add(mockTask)).called(1);
        expect(taskProvider.tasks.length, 0);
      },
    );

    test(
      'updateTask() should update a task in the box and notify listeners',
      () async {
        // Arrange
        when(mockTask.save()).thenAnswer((_) async => {});
        when(mockTaskBox.values).thenReturn([mockTask]);
        when(mockTask.title).thenReturn('Test Task');
        when(mockTask.description).thenReturn('Test Description');
        when(mockTask.priorityLevel).thenReturn(PriorityLevel.high);
        when(mockTask.isCompleted).thenReturn(false);

        // Act
        await taskProvider.loadTasks();
        await taskProvider.updateTask(mockTask);

        // Assert
        verify(mockTask.save()).called(1);
        expect(taskProvider.tasks.length, 1);
      },
    );

    test(
      'deleteTask() should delete a task from the box and notify listeners',
      () async {
        // Arrange
        when(mockTask.delete()).thenAnswer((_) async => {});
        when(mockTaskBox.values).thenReturn([mockTask]);
        when(mockTask.title).thenReturn('Test Task');
        when(mockTask.description).thenReturn('Test Description');
        when(mockTask.priorityLevel).thenReturn(PriorityLevel.high);
        when(mockTask.isCompleted).thenReturn(false);

        // Act
        await taskProvider.loadTasks();
        await taskProvider.deleteTask(mockTask);

        // Assert
        verify(mockTask.delete()).called(1);
        expect(taskProvider.tasks.length, 0);
      },
    );

    test(
      'toggleTaskCompletion() should toggle a task\'s completion status and notify listeners',
      () async {
        // Arrange
        when(mockTask.toggleCompleted()).thenReturn(null);
        when(mockTaskBox.values).thenReturn([mockTask]);
        when(mockTask.title).thenReturn('Test Task');
        when(mockTask.description).thenReturn('Test Description');
        when(mockTask.priorityLevel).thenReturn(PriorityLevel.high);
        when(mockTask.isCompleted).thenReturn(false);

        // Act
        await taskProvider.loadTasks();
        await taskProvider.toggleTaskCompletion(mockTask);

        // Assert
        verify(mockTask.toggleCompleted()).called(1);
        expect(taskProvider.tasks.length, 1);
      },
    );

    test('setSearchQuery() should filter tasks by search query', () async {
      // Arrange
      final task1 = MockTask();
      final task2 = MockTask();
      when(task1.title).thenReturn('Task One');
      when(task1.description).thenReturn('Description One');
      when(task2.title).thenReturn('Task Two');
      when(task2.description).thenReturn('Description Two');
      when(mockTaskBox.values).thenReturn([task1, task2]);

      // Act
      await taskProvider.loadTasks();
      await taskProvider.setSearchQuery('One');

      // Assert
      expect(taskProvider.tasks.length, 1);
      expect(taskProvider.tasks.contains(task1), true);
    });

    test('setFilterPriority() should filter tasks by priority', () async {
      // Arrange
      final task1 = MockTask();
      final task2 = MockTask();
      when(task1.priorityLevel).thenReturn(PriorityLevel.high);
      when(task2.priorityLevel).thenReturn(PriorityLevel.medium);
      when(mockTaskBox.values).thenReturn([task1, task2]);

      // Act
      await taskProvider.loadTasks();
      await taskProvider.setFilterPriority(PriorityLevel.high);

      // Assert
      expect(taskProvider.tasks.length, 1);
      expect(taskProvider.tasks.contains(task1), true);
    });

    test(
      'setFilterCompletionStatus() should filter tasks by completion status',
      () async {
        // Arrange
        final task1 = MockTask();
        final task2 = MockTask();
        when(task1.isCompleted).thenReturn(true);
        when(task2.isCompleted).thenReturn(false);
        when(mockTaskBox.values).thenReturn([task1, task2]);

        // Act
        await taskProvider.loadTasks();
        await taskProvider.setFilterCompletionStatus(true);

        // Assert
        expect(taskProvider.tasks.length, 1);
        expect(taskProvider.tasks.contains(task1), true);
      },
    );

    test(
      'applyFiltersAndSearch() should apply all filters correctly',
      () async {
        // Arrange
        final task1 = MockTask();
        final task2 = MockTask();
        final task3 = MockTask();
        when(task1.title).thenReturn('Task One');
        when(task1.description).thenReturn('Description One');
        when(task1.priorityLevel).thenReturn(PriorityLevel.high);
        when(task1.isCompleted).thenReturn(true);
        when(task2.title).thenReturn('Task Two');
        when(task2.description).thenReturn('Description Two');
        when(task2.priorityLevel).thenReturn(PriorityLevel.medium);
        when(task2.isCompleted).thenReturn(false);
        when(task3.title).thenReturn('Task Three');
        when(task3.description).thenReturn('Description Three');
        when(task3.priorityLevel).thenReturn(PriorityLevel.high);
        when(task3.isCompleted).thenReturn(false);
        when(mockTaskBox.values).thenReturn([task1, task2, task3]);

        // Act
        await taskProvider.loadTasks();
        await taskProvider.setSearchQuery('One');
        await taskProvider.setFilterPriority(PriorityLevel.high);
        await taskProvider.setFilterCompletionStatus(true);

        // Assert
        expect(taskProvider.tasks.length, 1);
        expect(taskProvider.tasks.contains(task1), true);
      },
    );

    test('dispose() should close the task box', () {
      // Act
      taskProvider.dispose();

      // Assert
      verify(mockTaskBox.close()).called(1);
    });
  });
}
